#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

#
# Test database tables and relational operators
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

source $testdir/setup.tcl

test insert_delete {creating table, insert, delete} \
            -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;
        var r real relation {i int, d float, c string} key {i};
        commit;

        disconnect();

		case
        when os.getenv('DURO_STORAGE') = 'POSTGRESQL' then
            connect('postgresql:///testdb');
        when os.getenv('DURO_STORAGE') = 'FOUNDATIONDB' then
            connect('foundationdb://');
		else
            connect('dbenv');
        end case;
        current_db := 'D';

        begin tx;
        insert r tup {i 3, d 1.0, c 'Z'};
        rollback;

        begin tx;
        try
            insert r tup { i array(3), d 1.0, c 'X' };
            io.put_line('array instead of integer attribute succeeded');
        catch e type_mismatch_error;
            ;
        end try;

        try
            insert r tup { i tup { i 3 }, d 1.0, c 'X' };
            io.put_line('tuple instead of integer attribute succeeded');
        catch e type_mismatch_error;
            ;
        end try;
        commit;

        begin tx;
        insert r tup {i 3, d 1.0, c 'Z'};
		commit;

		begin tx;
        try
            insert r relation {} {};
        catch err type_mismatch_error;
            io.put_line('type mismatch caught - empty relation');
        end try;
		try
		    commit;
		catch e no_running_transaction_error;
		    ;
		end try;

		begin tx;
        try
            insert r tup {i 4, d 1.0, c 'X', c2 'Y'};
        catch err type_mismatch_error;
            io.put_line('type mismatch caught - tuple with too many attributes');
        end try;

        var a init 1;
        insert r rel {tuple {i a, d 1.0, c 'X'}, tup {i 2, d 1.1, c 'Y'}};

        var s real init r key {i};

        var t init tuple {i 2 + 1, d 1.0, c 'Z'};
        insert r update t : {i := i + 1};

        io.put_line(cast_as_string(count(r)));
        io.put_line(cast_as_string(count(s)));

        var i real rel {i int};
        -- The i in the where clause should not be resolved to the table above
        io.put_line((tuple from r where i=2).c);
        
        -- Test table with 2 keys

        var r2 real relation {no int, id string, str string} key {no} key {id};
        insert r2 tup{no 1, id '1', str 'xxx'};
		commit;

		begin tx;
        -- Test key #1
        try
            insert r2 tup {no 1, id '2', str 'yyy'};
        catch err key_violation_error;
            io.put_line('key violation caught (1)');
        end try;
		try
		    commit;
		catch e no_running_transaction_error;
		    ;
		end try;

		begin tx;
        -- Test key #2
        try
            insert r2 tup {no 2, id '1', str 'zzz'};
        catch err key_violation_error;
            io.put_line('key violation caught (2)');
        end try;
		try
		    commit;
		catch e no_running_transaction_error;
		    ;
		end try;

		begin tx;
        insert r2 tup {no 2, id '2', str 'xxx'};

        -- Try to delete with only the key matching
        delete r2 tup { no 1, id '2', str 'yyy' };

        -- r2 must be unchanged
        if r2 <> rel { tup {no 1, id '1', str 'xxx'},
                       tup {no 2, id '2', str 'xxx'} } then
             io.put('invalid value of r2: ');
             io.put(r2);
             io.put_line('');
        end if; 

        -- Try the same with i_delete, must fail
        try
            i_delete r2 tup { no 1, id '2', str 'yyy' };
            io.put_line('delete of tuple where only key matched succeeded');
        catch err not_found_error;
            ;
        end try;

        -- Array instead of integer
        try
            delete r2 tup{no 1, id array('1'), str 'xxx'};
            io.put_line('delete of tuple with array instead of string succeeded');
        catch e type_mismatch_error;
            ;
        end try;
            

        -- Table without KEY (implicit all-key)
        var r3 real rel {n int, s string};
        insert r3 tup {n 1, s 'a'};
        insert r3 tup {n 1, s 'b'};
        insert r3 tup {n 2, s 'a'};
        insert r3 tup {n 3, s 'a'};
        try
            d_insert r3 tup {n 1, s 'a'};
        catch err element_exists_error;
            io.put_line('element_exists_error');
        end try;
        io.put(count(r3)); io.put_line(' tuples');

        commit;

        -- connect() without preceding disconnect()
        case
        when os.getenv('DURO_STORAGE') = 'POSTGRESQL' then
            connect('postgresql:///testdb');
        when os.getenv('DURO_STORAGE') = 'FOUNDATIONDB' then
            connect('foundationdb://');
        else
            connect('dbenv');
        end case;

        var hs init 'a';
        begin tx;
        delete r3 where n = 1 and s = hs;
        io.put(count(r3)); io.put_line(' tuples');
        delete r3 rel { tup {n 1, s 'b'} };
        try
            i_delete r3 rel { tup {n 1, s 'b'}, tup {n 2, s 'a'} };
        catch err not_found_error;
            io.put_line('2nd delete of same tuple failed');
        end try;
        io.put(count(r3)); io.put_line(' tuples');

        delete r3 tup {n 2, s 'a'};
        io.put(count(r3)); io.put_line(' tuple');
        delete r3;
        io.put_line(if is_empty(r3) then 'empty' else 'not empty');
        
        /* Create local table with multiple keys in the context of an environment */
        var p private relation { n int, m int } key { n } key { m };
        insert p tuple { n 1, m 1 };
        io.put((tuple from p where m = 1).n);
        io.put_line('');
        drop var p;
    }
} -result {type mismatch caught - empty relation
type mismatch caught - tuple with too many attributes
4
3
Y
key violation caught (1)
key violation caught (2)
element_exists_error
4 tuples
3 tuples
2nd delete of same tuple failed
2 tuples
1 tuple
empty
1
}

test update {creating table and updating tuples} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;
        var r real relation {k int, v string}
                init rel { tup { k 1, v 'One' },
                           tup { k 2, v 'Two' }}
                key {k};
        
        -- Updating value
        update r where k = 1 { v := '1' };
        io.put_line((tuple from r where k = 1).v);
        io.put_line((tuple from r where k = 2).v);

        -- Updating values
        update r { v := v || v };
        io.put_line((tuple from r where k = 1).v);
        io.put_line((tuple from r where k = 2).v);

        -- Updating keys
        update r { k := k + 1 };
        io.put_line((tuple from r where k = 2).v);
        io.put_line((tuple from r where k = 3).v);
        
        commit;

        begin tx;
        -- Update that would violate the key constraint
        try
            update r { k := 1 };
        catch err key_violation_error;
            io.put_line('key violation caught');
        end try;
        rollback;

        begin tx;
        -- Try with variable
        var hk init 1;
        try
            update r { k := hk };
        catch err key_violation_error;
            io.put_line('key violation caught');
        end try;
        rollback;

        begin tx;
        -- Update combining both tuples into one
        const cv 'Uno';
        update r { k := 1, v := cv };
        io.put_line((tuple from r).v);

        commit;
    }
} -result {1
Two
11
TwoTwo
11
TwoTwo
key violation caught
key violation caught
Uno
}

test in {IN operator} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;
        var r real relation {i int, d float, c string}
               init rel { tup { i 1, d 0.61, c 'xx' } } key { i };
        
        io.put(tup { i 1, d 0.61, c 'xx' } IN r);
        io.put_line('');
        
        commit;

        begin transaction;

        io.put(tup { i 1, d 0.0, c 'xx' } IN r);
        io.put_line('');
        
        io.put(tup { i 1, d 0.0, c 'xx' } IN r);
        io.put_line('');

        try
            io.put(tup { j 1, d 0.61, c 'xx' } IN r);
            io.put_line('IN with different attribute name succeeded');
        catch e type_mismatch_error;
            ;
        end try;

        try
            io.put(tup { i array(1), d 0.61, c 'xx' } IN r);
            io.put_line('IN with array succeeded');
        catch e type_mismatch_error;
            ;
        end try;

    }
} -result {TRUE
FALSE
FALSE
}

test for_in_drop {DROP in FOR .. IN} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;
        var r real relation {no int, name string} key {no};
        insert r rel{tup{no 1, name 'one'}, tup{no 2, name 'two'}};

        var t tup{no int};
        try
            for t in r {no} order();
                drop var r;
            end for;
        catch err not_supported_error;
            io.put_line('not_supported caught');
        end try;
        commit;
    }
} -result {not_supported caught
}

test invalid_type {invalid (scalar) type for table} -setup $SETUP -cleanup $CLEANUP -match glob -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
    	current_db := 'D';

	    begin transaction;
    	var ir real int key {};
    }
}  -returnCodes {1} -result {*type_mismatch_error*}

test extend {EXTEND} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        -- Tables with same name as attributes
        var b real relation { a int };
        var c real relation { a int };

        var t1 real relation { a int, b string, c int }
        		init relation { tuple {a 1, b 'x', c 1},
        		        tuple {a 2, b 'yo', c 10} } key { a };

        var t2x virtual extend t1: { bx := b || b, cx := c + 100 };

        var tpx tup { a int, bx string, cx int };
        for tpx in t2x { a, bx, cx } order (a asc);
            io.put(tpx.a); io.put(' ');
            io.put(tpx.bx); io.put(' ');
            io.put(tpx.cx); io.put_line('');
        end for;

        commit;

        -- Test query, insert, delete
        begin tx;

        io.put_line((tuple from (extend t1: {bb := b || b} where a = 1)).bb);

        insert t2x rel { tup { a 3, b 'u', c 1, bx 'uu', cx 101 } };

        insert t2x tup { a 4, b 't ', c 1000, bx 't t ', cx 1100 };

        try
            insert t2x rel { tup { a 5, b 'x', c 1, bx 'x', cx 101 } };
            io.put_line('INSERT succeeded where b and bx do not match');
        catch err predicate_violation_error;
            ;
        end try;

        try
            insert t2x tup { a 5, b 'x', c 1, bx 'xx', cx 102 };
            io.put_line('Tuple INSERT succeeded where b and bx do not match');
        catch err predicate_violation_error;
            ;
        end try;

        try
            delete t2x rel { tup { a 1, b 'x', c 1, bx 'xxx', cx 101 } };
            io.put_line('DELETE succeeded where b and bx do not match');
        catch err not_found_error;
            ;
        end try;

        delete t2x where cx = 110;

        delete t2x rel { tup { a 1, b 'x', c 1, bx 'xx', cx 101 } };

        delete t2x tup { a 3, b 'u', c 1, bx 'uu', cx 101 };

        for tpx in t2x { a, bx, cx } order (a asc);
            io.put(tpx.a); io.put(' ');
            io.put(tpx.bx); io.put(' ');
            io.put(tpx.cx); io.put_line('');
        end for;

        commit;
    }
} -result {1 xx 101
2 yoyo 110
xx
4 t t  1100
}

test project {project} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t1 real relation { a int, b string, c int }
        		init relation { tuple {a 1, b 'x', c 1},
        		        tuple {a 2, b 'yo', c 10} } key { a } default { c 0 };

        var t1p virtual t1 { a, b };

        var tp tup { a int, b string };
        for tp in t1p order (a asc);
            io.put(tp.a); io.put(' ');
            io.put(tp.b); io.put_line('');
        end for;
        io.put_line('');

        commit;

        -- Test insert, update, delete
        begin tx;

        insert t1p rel { tup { a 3, b 'u' } };

        insert t1p tup { a 4, b ' t' };

        update t1p where a = 2 { b := 'ui io' };

        try
            update t1p where a = 2 { c := 7 };
            io.put_line('update of attribute not present in virtual table succeeded');
        catch err name_error;
            ;
        end try;

        for tp in t1p order (a asc);
            io.put(tp.a); io.put(' ');
            io.put(tp.b); io.put_line('');
        end for;
        io.put_line('');

        try
            delete t1p where c = 10;
            io.put_line('delete with ref to attribute not present in virtual table succeeded');
        catch err name_error;
            ;
        end try;

        delete t1p where a = 2;
        delete t1p where b = 'u';

        for tp in t1p order (a asc);
            io.put(tp.a); io.put(' ');
            io.put(tp.b); io.put_line('');
        end for;

        commit;
    }
} -result {1 x
2 yo

1 x
2 ui io
3 u
4  t

1 x
4  t
}

test join_extend {Natural JOIN/EXTEND}  -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t1 real relation {a int, b string}
        		init relation { tuple {a 1, b 'x'}, tuple {a 2, b 'y'} } key {a};
        var t2 real init rel { tup {b 'x', c 1}, tup {b 'x', c 2}, tup {b 'y', c 3} };
        var t3 real init rel { tup {b 'x'}, tup {b 'y'} };

        var tp tup {a int, b string, c int};
        for tp in t1 join t2 order (a asc, b asc, c asc);
            io.put(tp.a); io.put(' ');
            io.put(tp.b); io.put(' ');
            io.put(tp.c); io.put_line('');
        end for;

        for tp in t1 join extend t3: { c := if b = 'x' then 0 else 1 } order (a asc, b asc, c asc);
            io.put(tp.a); io.put(' ');
            io.put(tp.b); io.put(' ');
            io.put(tp.c); io.put_line('');
        end for;

        -- Empty EXTEND
        var tp2 tuple same_heading_as(t1);
        for tp2 in t1 join extend t3: { } order (a asc, b asc);
            io.put(tp2.a); io.put(' ');
            io.put(tp2.b); io.put_line('');
        end for;

        -- EXTEND adding 2 attributes, using user-def operator

        operator dup_string(s string) returns string;
            return s || s;
        end operator;

        var tp3 tup {a int, b string, c int, d string};
        for tp3 in t1 join extend t3: { c := if b = 'x' then 0 else 1, d := dup_string(b) }
                order (a asc, b asc, c asc);
            io.put(tp3.a); io.put(' ');
            io.put(tp3.b); io.put(' ');
            io.put(tp3.c); io.put(' ');
            io.put(tp3.d); io.put_line('');
        end for;

        commit;
    }
} -result {1 x 1
1 x 2
2 y 3
1 x 0
2 y 1
1 x
2 y
1 x 0 xx
2 y 1 yy
}

test join_rename_index {JOIN with index}  -setup $SETUP -cleanup $CLEANUP -match glob -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin tx;

        var orders real rel {id int, cust_id int} key {id};
        
        insert orders rel {tup {id 101, cust_id 1},
                           tup {id 102, cust_id 1},
                           tup {id 103, cust_id 2},
                           tup {id 104, cust_id 2},
                           tup {id 105, cust_id 3} };

        var customers real rel {id int, name string} key {id};
        
        insert customers rel {tup {id 1, name 'Jack'},
                              tup {id 2, name 'Jill'},
                              tup {id 3, name 'Karl'} };

        explain orders join customers rename { id as cust_id } order();
        
        var tp tup {id int, name string};
        for tp in (orders join customers rename { id as cust_id }) { id, name } order (id asc);
           io.put(tp.id);
           io.put(' ');
           io.put(tp.name);
           io.put_line('');
        end for;
        
        commit;
    }
} -result {*INDEX customers$0*
101 Jack
102 Jack
103 Jill
104 Jill
105 Karl
}

test join_rename_nuindex {JOIN with rename and non-unique index}  -setup $SETUP \
        -cleanup $CLEANUP -match glob -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin tx;
		var r1 real rel {a int, b int}
		    init rel { tup {a 1, b 1 }, tup {a 2, b 2 }} key {a};
		var r2 real rel {c int, d int}
		    init rel { tup {c 1, d 1 }, tup {c 2, d 1 }} key {c};
		index r2_d r2 (d);

		explain r1 join r2 rename { d as b } order();
		
		var tp tup {a int, b int, c int};
		for tp in r1 join r2 rename { d as b } order(c asc);
		    io.put(tp.a); io.put(' ');
		    io.put(tp.b); io.put(' ');
		    io.put(tp.c); io.put_line('');
		end for;

		explain r2 rename { d as b } join r1 order();
		
		for tp in r2 rename { d as b } join r1 order(c asc);
		    io.put(tp.a); io.put(' ');
		    io.put(tp.b); io.put(' ');
		    io.put(tp.c); io.put_line('');
		end for;

		commit;
    }
} -result {*INDEX r2_d*
1 1 1
1 1 2
*INDEX r2_d*
1 1 1
1 1 2
}

test union {UNION and D_UNION} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t1 real init relation { tuple {n 1, s 'x'}, tuple {n 2, s 'y'} } key {n};
        var t2 real init relation { tuple {n 2, s 'y'}, tuple {n 3, s 'z'} } key {n};
        var t3 real init relation { tuple {n 2, s 'yy'}, tuple {n 3, s 'z'} } key {n};

        var tp tuple same_heading_as(t1);
        for tp in t1 union t2 order (n asc, s asc);
            io.put(tp.n); io.put(' ');
            io.put_line(tp.s);
        end for;
        io.put_line('');

        for tp in t1 union t3 order (n asc, s asc);
            io.put(tp.n); io.put(' ');
            io.put_line(tp.s);
        end for;
        io.put_line('');

        try
            for tp in t1 d_union t2 order (n asc, s asc);
                io.put(tp.n); io.put(' ');
                io.put_line(tp.s);
            end for;
        catch err element_exists_error;
            io.put_line('duplicate tuple caught');
        end try;

        for tp in t1 d_union t3 order (n asc, s asc);
            io.put(tp.n); io.put(' ');
            io.put_line(tp.s);
        end for;
    }
} -result {1 x
2 y
3 z

1 x
2 y
2 yy
3 z

duplicate tuple caught
1 x
2 y
2 yy
3 z
}

test where {WHERE virtual table} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;
        var parts real rel { id int, colour string } key { id };
        var green_parts virtual parts where colour = 'green';

        insert parts tup { id 1, colour 'red' };
        commit;

        var pr private rel { id int };

        begin tx;
        insert green_parts tup { id 2, colour 'green' };
        try
            insert green_parts rel { tup { id 3, colour 'green' },
                    tup { id 4, colour 'red' } },
                    insert pr tup { id 1 };
            io.put_line('insert of red part into green parts succeeded');
        catch err predicate_violation_error;
            ;
        end try;
        io.put_line(cast_as_string(count(parts)));
        io.put_line(cast_as_string(count(green_parts)));
        io.put_line('');

        insert green_parts rel { tup { id 3, colour 'green' },
                    tup { id 4, colour 'green' } },
                    insert pr tup { id 2 };

        var part tuple same_heading_as(parts);
        for part in parts order (id asc);
            io.put(part.id);
            io.put_line('');
        end for;
        commit;

        io.put_line('');

        io.put((tuple from pr).id);
        io.put_line('');

        begin tx;
        try
            delete green_parts rel { tup { id 1, colour 'red' },
                    tup { id 2, colour 'green' } };
            io.put_line('delete of red part from green parts succeeded');
        catch err not_found_error;
            ;
        end try;

        delete green_parts tup { id 2, colour 'green' },
                delete pr tup { id 2 };
        
        delete green_parts where id = 4;

        for part in parts order (id asc);
            io.put(part.id);
            io.put_line('');
        end for;
        io.put(count(pr)); io.put_line('');
        commit;
    }
} -result {2
1

1
2
3
4

2
1
3
0
}

test ra {relational algebra} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt  -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t1 real relation {a int, b string}
        		init relation { tuple {a 1, b 'x'}, tuple {a 2, b 'y'} } key {a};
        var t2 real relation {a int} key {a};

        var v2 virtual t2 where a <= 2;

        try
            drop var t2;
        catch err in_use_error;
            ;
        end try;

        insert t2 relation { tuple {a 2}, tuple {a 3} };

        -- project / INTERSECT
        io.put(with (p := t1 { a }, ist := p intersect t2): (tuple from ist).a); io.put_line('');

        -- SEMIMINUS / NOT MATCHING
        var tp init tuple from (t1 SEMIMINUS t2);
        io.put(tp.a); io.put(' ');
        io.put_line(tp.b);
        io.put((tuple from (t2 NOT MATCHING t1)).a); io.put_line('');

        -- remove
        io.put((tuple from (t1 where a = 1 { ALL BUT a })).b); io.put_line('');
        try
            io.put((tuple from (t1 where a = 1 { ALL BUT a })).a); io.put_line('');
        catch err name_error;
            io.put_line('name_error caught');
        end try;

        -- RENAME
        io.put((tuple from (v2 rename { a as na })).na); io.put_line('');

        io.put((tuple from (v2 rename { })).a); io.put_line('');

        var tpr init tuple from t1 rename { a as na, b as nb } where na = 2;
        io.put(tpr.na); io.put(' ');
        io.put_line(tpr.nb);

        -- UPDATE expression
        io.put((tuple from (update v2 : { a := a + 1 })).a); io.put_line('');

        -- no-op UPDATE
        io.put((tuple from (update v2 : { })).a); io.put_line('');

        var va init 1;
        io.put_line((tuple from (t1 where a = va)).b);

        io.put(is_empty(v2 where a>2)); io.put_line('');
        io.put(is_empty(v2 intersect rel{tup{a 2}})); io.put_line('');

        -- Test nested virtual table
        var vv2 virtual v2 where a>=2;
        io.put((tuple from vv2).a); io.put_line('');        

        var tpa tup{a int};
        for tpa in t1 {a} order (a asc);
            io.put(tpa.a); io.put_line('');
        end for;

        var tpb tup{b string};
        for tpb in t1 {all but a} order (b asc);
            io.put_line(tpb.b);
        end for;

        for tp in t1 order (b asc);
            io.put_line(tp.b);
        end for;

        commit;
    }
} -result {2
1 x
3
x
name_error caught
2
2
2 y
3
2
x
TRUE
FALSE
2
1
2
x
y
x
y
}

test virtual_assign {assignment to virtual tables} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        var emp real rel{emp_id int, dept_id int, name string} key {emp_id};
        commit;
    }
    exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        var empd1 virtual emp where dept_id = 1;
        insert empd1 tup {emp_id 1, dept_id 1, name 'Smith'};
        commit;
    }
    exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;

        insert empd1 tup {emp_id 2, dept_id 1, name 'Jones'};

        try
            -- Must fail because of dept_id=2
            insert empd1 tup {emp_id 3, dept_id 2, name 'Miller'};
        catch err predicate_violation_error;
            io.put_line('predicate violation caught');
        end try;

        var emptp tup same_heading_as(empd1);
        for emptp in empd1 order (emp_id asc);
            io.put_line(emptp.name);
        end for;

        commit;
    }
} -result {predicate violation caught
Smith
Jones
}

test tupleattr {tuple-valued attributes} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var tr real rel{no int, tp tup{n int, s string}} key{no};
        insert tr tup{no 1, tp tup{n 10, s 'one'}};

        commit;
    }
    # Test with new interpreter instance
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;

        -- test tuple comparison in WHERE
        var t tup same_heading_as(tr);
        t := tuple from tr where no = 1 and tp = tup{n 10, s 'one'};
        io.put(t.no); io.put_line('');
        io.put(t.tp.n); io.put_line('');
        io.put(t.tp.s); io.put_line('');
        commit;
    }
} -result {1
10
one
}

test updop {user defined update operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        operator defop() updates {};
	        begin transaction;
	        
            var tp init tuple {a 0, b "duro"};
            var r real relation same_heading_as(tp) key {a};

            var v virtual (extend r : {bx := b || 'x'});

            commit;
        end operator;

        operator insop(t relation {b string, a int}) updates {t};
            insert t tuple {a 0, b "duro"};
        end operator;

        defop();
        insop(r);
        io.put((tuple from v).bx); io.put_line('');
        commit;
    }
} -result {durox
}

test roop {user defined read-only operators} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        operator int_to_rel(n int) returns rel{no int};
            var i int;
            var r private rel{no int} key {no};
            for i := 1 to n;
                insert r tup{no i};
            end for;
            return r;
        end operator;

        io.put(is_empty(int_to_rel(0))); io.put_line('');
        io.put(count(int_to_rel(3))); io.put_line('');
    }
} -result {TRUE
3
}

test zero_attrs {Tables with zero attributes} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;
        var ev virtual relation {i int} {};
        commit;

        disconnect();

        -- Connect again and read virtual table
        case
        when os.getenv('DURO_STORAGE')='POSTGRESQL' then
            connect('postgresql:///testdb');
        when os.getenv('DURO_STORAGE')='FOUNDATIONDB' then
            connect('foundationdb://');
        else
            connect('dbenv');
        end case;
        current_db:='D';
        begin tx;
        io.put(ev); io.put_line('');
        commit;
    }
} -result {RELATION {}
}

test logic {Logic operators} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t real relation {a int, b int} key {a, b};

        insert t relation { tuple {a 1, b 1}, tuple {a 1, b 2},
                tuple {a 2, b 1}, tuple {a 2, b 2} };

        var va virtual t where a=1 or b=1;
        var vo virtual t where a=1 and b=1;
        var vx virtual t where a=1 xor b=1;

        var arr array tuple {a int, b int};

        try
            load arr from vo order(i asc, b asc);
        catch err;
            io.put_line('invalid order clause');
        end try;

        -- Virtual table as variable
        load arr from va order(a asc, b asc);

        var i int;
        for i:= 0 to length(arr)-1;
			io.put(arr[i].a);
			io.put(' ');
			io.put(arr[i].b); io.put_line('');			
		end for;

		io.put_line('');

        -- Virtual table as expression
        load arr from t where a=1 or b=1 order(a asc, b asc);

        for i:= 0 to length(arr)-1;
			io.put(arr[i].a);
			io.put(' ');
			io.put(arr[i].b); io.put_line('');			
		end for;

		io.put_line('');

        load arr from vo order(a asc, b asc);
        
        for i:= 0 to length(arr)-1;
			io.put(arr[i].a);
			io.put(' ');
			io.put(arr[i].b); io.put_line('');			
		end for;

		io.put_line('');

        load arr from t where a=1 and b=1 order(a asc, b asc);
        
        for i:= 0 to length(arr)-1;
			io.put(arr[i].a);
			io.put(' ');
			io.put(arr[i].b); io.put_line('');			
		end for;

		io.put_line('');

        load arr from vx order(a asc, b asc);
        for i:= 0 to length(arr)-1;
			io.put(arr[i].a);
			io.put(' ');
			io.put(arr[i].b); io.put_line('');			
		end for;

		io.put_line('');

        load arr from t where a=1 xor b=1 order(a asc, b asc);
        for i:= 0 to length(arr)-1;
			io.put(arr[i].a);
			io.put(' ');
			io.put(arr[i].b); io.put_line('');			
		end for;

		io.put_line('');

        -- Tuple attribute as target
        var tp tuple { a array tuple same_heading_as(t) };
        load tp.a from t where a=2 order (b asc);
        for i:= 0 to length(tp.a) - 1;
			io.put(tp.a[i].a);
			io.put(' ');
			io.put(tp.a[i].b); io.put_line('');			
		end for;        
        
        commit;
    }
} -result {invalid order clause
1 1
1 2
2 1

1 1
1 2
2 1

1 1

1 1

1 2
2 1

1 2
2 1

2 1
2 2
}

test aggregate {Aggregate operators} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t real relation {b BOOLEAN} key {b};

		insert t tup {b true};
		insert t tup {b false};

		io.put(all(t, b)); io.put_line('');
		io.put(and(t, b)); io.put_line('');
		io.put(any(t, b)); io.put_line('');
		io.put(or(t, b)); io.put_line('');

        commit;
    }
} -result {FALSE
FALSE
TRUE
TRUE
}

test summarize {SUMMARIZE} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t real relation {a int, b int} key {a, b};

		insert t tup {a 1, b 0};
		insert t tup {a 1, b 1};
		insert t tup {a 2, b 1};
		insert t tup {a 2, b 2};

        var b real relation { n int };
		var v virtual SUMMARIZE t PER t {a} : {
				a_sum := SUM(b),
		        a_all := ALL(b > 0),
		        a_and := AND(b > 0),
		        a_any := ANY(b > 0),
		        a_or := OR(b > 0) };

        var arr array tuple same_heading_as (v);

        load arr from v order(a asc);

        var i int;
        for i:= 0 to length(arr)-1;
			io.put(arr[i].a_sum);
			io.put(' ');
			io.put(arr[i].a_all);
			io.put(' ');
			io.put(arr[i].a_and);
			io.put(' ');
			io.put(arr[i].a_any);
			io.put(' ');
			io.put(arr[i].a_or); io.put_line('');
		end for;

        commit;
        
        -- Test table with array attribute
        begin tx;
        
        var at real rel {a array int, b int} key {a, b};
        insert at tup {a array(1), b 1};

        var tp tup {a array int, c int};
        tp := tuple from summarize at per at {a} : {c := count(b)};

        io.put(length(tp.a));
        io.put(' ');
        io.put(tp.c);
        io.put_line('');
        
        commit;
    }
} -result {1 FALSE FALSE TRUE TRUE
3 TRUE TRUE TRUE TRUE
1 1
}

test relrel {table with relation attribute} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin transaction;

        var t real relation {x int, a string, r relation{s string, i int}} key {x};

		insert t tuple{x 1, a 'hm', r rel{tup{i 5, s 'yo'}}};

		var tp init tuple from (tuple from t).r;

        io.put(tp.i); io.put_line('');
        io.put_line(tp.s);
        commit;
    }
} -result {5
yo
}

if {$dbenvname == "dbenv"} {
    set expected {*INDEX r_ad_ai*
*INDEX r_ad_ai*
36
37
38
39
}
} else {
    set expected {*
*
36
37
38
39
}
}

test create_index {creating index} -setup $SETUP -cleanup $CLEANUP -match glob -body {
    exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        var r real relation {ai int, ad float, ac string} key {ai};
        commit;

        begin tx;
        index r_ac r (ac);
        index r_ad_ai r (ad, ai);
        commit;

        begin tx;
        var i int;
        for i:= 1 to 40;
            insert r tup{ai i, ad cast_as_float(i / 10), ac cast_as_string(i)};
        end for;
        explain r where ai > 35 and ad = 3.0 order();
        explain r where 35 < ai and 3.0 = ad order();

        var t tuple same_heading_as(r);
        for t in r where ai > 35 and ad = 3.0 order(ai asc);
            io.put(t.ai); io.put_line('');
        end for;

        commit;

        begin tx;
        drop index r_ac;
        drop index r_ad_ai;
        commit;
    }
} -result $expected

test real_default {public real table with default values} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r1 real relation {i int, r float, c string} key {i}
                default {r 1.2, c 'xyz'};
        insert r1 tup {i 5};
        insert r1 rel {i int} {};
		commit;

		begin tx;
        -- Must fail
        try
            insert r1 rel {} {};
        catch err type_mismatch_error;
            io.put_line('type_mismatch_error caught');
        end try;
		try
			commit;
		catch err no_running_transaction_error;
			;
		end try;

		begin tx;
        insert r1 rel {tup {i 1}, tup {i 2}};

        var r2 real relation {i int, r float, c string}
                init rel {tup {i 0, r 1.0, c 'Zz'}}
                key {i} key {c}
                default {r 1.2, c 'xyz'};
        insert r2 tup {i 5};
        var t2 init tuple from (r2 where i=5);

        var r3 real relation {i int, r float, c string}
                init r2 default {r 1.2, c 'xyz'};
        insert r3 tup {i 6, c 'xyy'};
        var t3 init tuple from (r3 where i=6);

        -- Invalid keys
        try
        	var r4 real rel {no int, r float, name string}
            	    key {no} key {no, name} default {name 'John Doe'};
        catch err invalid_argument_error;
            io.put_line('r4: invalid_argument_error caught');
        end try;

        var t1 tuple same_heading_as(r1);
        for t1 in r1 order (i asc);
            io.put(t1.i); io.put(' ');
            io.put(cast_as_integer(t1.r * 100.0)); io.put(' ');
            io.put(t1.c); io.put_line('');
        end for;

        commit;

        io.put(t2.i); io.put(' ');
        io.put(cast_as_integer(t2.r * 100.0)); io.put(' ');
        io.put(t2.c); io.put_line('');

        io.put(t3.i); io.put(' ');
        io.put(cast_as_integer(t3.r * 100.0)); io.put(' ');
        io.put(t3.c); io.put_line('');
    }
} -result {type_mismatch_error caught
r4: invalid_argument_error caught
1 120 xyz
2 120 xyz
5 120 xyz
5 120 xyz
6 120 xyy
}

test dbconstraint {db/table constraints 1} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin transaction;

        operator create_constraint() updates {};
            constraint cr count(r) <= 1;
        end operator;

        operator drop_constraint() updates {};
            drop constraint cr;
        end operator;

        var r real relation {no integer, name string}
                init relation {tuple {no 1, name 'one'}}
                key {no};

        create_constraint();

        try
            insert r tuple {no 2, name 'two'};
        catch err predicate_violation_error;
            io.put_line('caught predicate violation: ' || THE_MSG(err));
        end try;

        try
            drop var r;
        catch err in_use_error;
            io.put_line('caught in_use_error');
        end try;

        drop_constraint();
    }
} -result {caught predicate violation: cr
caught in_use_error
}

test dbconstraint2 {db/table constraints 2} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin transaction;
        var r2 real rel {no int} key {no};
        
        constraint cr2 count(r2) <= 1;

        commit;
    }
    # Check for bug which caused the constraint to be still in memory
    # after DROP CONSTRAINT when constraints_read was false
    exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        drop constraint cr2;
        
        begin tx;
        drop var r2;
        commit;
    }
}

# Test referential constraint, including optimization and EXPLAIN <assignment>
test refconstraint {referential constraint} -setup $SETUP -cleanup $CLEANUP -body {
    puts -nonewline [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        var customers real rel {cust_id int, name string} key {cust_id};
        var orders real rel {order_id int, cust_id int, info string}
                key {order_id} default {info ''};
        constraint o_c orders {cust_id} subset_of customers {cust_id};

        insert customers rel{tup{cust_id 1, name 'James'},
                tup{cust_id 2, name 'Joan'}};

        insert orders tup{order_id 1, cust_id 1};

        try
            insert orders tup{order_id 2, cust_id 3};
        catch err predicate_violation_error;
            io.put_line('insert into orders caught');
        end try;

        try
            insert orders rel{ tup{order_id 2, cust_id 3},
                    tup{order_id 3, cust_id 3}};
        catch err predicate_violation_error;
            io.put_line('2nd insert into orders caught');
        end try;

        try
            delete customers where cust_id=1;
        catch err predicate_violation_error;
            io.put_line('delete from customers caught');
        end try;

        try
            delete customers tup {cust_id 1, name 'James'};
        catch err predicate_violation_error;
            io.put_line('2nd delete from customers caught');
        end try;

        try
            delete customers rel { tup {cust_id 1, name 'James'} };
        catch err predicate_violation_error;
            io.put_line('3rd delete from customers caught');
        end try;

        -- Must succeed
        delete customers where cust_id=2;

        commit;
    }]

    #
    # Check optimization
    #
    set checks [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        explain insert orders tup{order_id 2, cust_id 2};
        commit;
    }]
    if {[string match {*orders*} $checks]} {
        puts "insert check #1 refers to orders: $checks"
    }

    set checks [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        explain insert customers tup{cust_id 2, name 'John'};
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "insert check #2 refers to orders or customers: $checks"
    }    

    set checks [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        explain delete orders where order_id=1;
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "delete check #1 refers to orders or customers: $checks"
    }    

    set checks [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        explain delete customers where cust_id=1;
        commit;
    }]
    if {![string match {*INDEX customers$0*} $checks]} {
        puts "delete check #2 does not use primary index of customers"
    }

    set checks [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        explain update orders where order_id=1 {info := 'yo'};
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "update check #1 refers to orders or customers: $checks"
    }    

    set checks [exec $testdir/../../dli/durodt -e $dbenvname -d D << {
        begin tx;
        explain update customers where cust_id=1 {name := 'Karlheiz'};
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "update check #2 refers to orders or customers: $checks"
    }    

} -output {insert into orders caught
2nd insert into orders caught
delete from customers caught
2nd delete from customers caught
3rd delete from customers caught
}

test trconstraint {Transition constraint} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin transaction;

        var rs real rel { id int, name string, status int } key { id };

        constraint trc is_empty(
                (((rs' { id, status }) rename { status as status' })
                join (rs { id, status })) where status' > status);

        insert rs tup { id 1, name 'yo', status 0 };

        update rs where id = 1 { status := 1 };

        try
            update rs where id = 1 { status := 0 };
        catch err predicate_violation_error;
            io.put_line('decreasing status caught');
        end try;
    }
} -result {decreasing status caught
}

test matching_index {MINUS, INTERSECT, SEMIJOIN, SEMIMINUS with index on table #2} -setup $SETUP -cleanup $CLEANUP -match glob -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin transaction;

        var t1 real rel{b int, c string}
                init RELATION {TUPLE {c 'B', b 1}, TUPLE {c 'C', b 1}};

        var t2 real rel{a int, b int, c string}
                init RELATION {TUPLE {a 1, c 'A', b 1}, TUPLE {a 2, c 'B', b 1},
                               TUPLE {a 3, c 'B', b 1}, TUPLE {a 4, c 'B', b 2},
                               TUPLE {a 5, c 'B', b 3}}
                 key {a};

        index t2_bc t2 (b, c);
        
        commit;

        begin tx;

        explain t1 semijoin t2 order();
        explain t1 semiminus t2 order();
        explain t1 intersect t2 {b, c} order();
        explain t1 minus t2 {b, c} order();

        var tp tuple {b int, c string};

        tp := tuple from (t1 semijoin t2);
        io.put(tp.b); io.put(' ');
        io.put(tp.c); io.put_line('');
        
        tp := tuple from (t1 semiminus t2);
        io.put(tp.b); io.put(' ');
        io.put(tp.c); io.put_line('');
        
        tp := tuple from (t1 intersect t2 {b, c});
        io.put(tp.b); io.put(' ');
        io.put(tp.c); io.put_line('');

        tp := tuple from (t1 minus t2 {b, c});
        io.put(tp.b); io.put(' ');
        io.put(tp.c); io.put_line('');
        
        commit;
    }
} -result {*INDEX t2_bc*
*INDEX t2_bc*
*INDEX t2_bc*
*INDEX t2_bc*
1 B
1 C
1 B
1 C
}

test index_reopen {creating and filling a table with an index and accessing it after closing and reopening the connection} \
 -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;

        var dictionary real relation { word string, normword string } key { word };
        index dict_normword dictionary (normword);
        
        insert dictionary tup { normword 'an', word 'an' };
        insert dictionary tup { normword 'blau', word 'blau' };
        insert dictionary tup { normword 'Bo', word 'Bo"' };
        insert dictionary tup { normword 'Boot', word 'Boot' };

        commit;

        disconnect();

        case
        when os.getenv('DURO_STORAGE') = 'POSTGRESQL' then
            connect('postgresql:///testdb');
        when os.getenv('DURO_STORAGE') = 'FOUNDATIONDB' then
            connect('foundationdb://');
        else
            connect('dbenv');
        end case;
        current_db := 'D';

        begin tx;
        io.put(is_empty(dictionary where normword = 'an')); io.put_line('');
        commit;

        begin tx;
        delete dictionary;
        commit;
    }
} -result {FALSE
}

test utypetable {table with attribute of user-defined type} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin transaction;

        type utype
            possrep ( s string )
            init utype('');

        implement type utype;
        end implement;

        var utr real rel{id int, uv utype} key {id};
        insert utr rel{tup{id 1, uv utype('a')},
                       tup{id 2, uv utype('b')}};

        try
            io.put_line(the_s(utr));
        catch err invalid_argument_error;
            io.put_line('invalid argument caught');
        end try;

        io.put_line(the_s((tuple from utr where id=1).uv));

        commit;

        begin tx;

        try
            drop type utype;
        catch err in_use_error;
            io.put_line('caught in_use_error');
        end try;

        drop var utr;
        drop type utype;

        commit;
    }
} -result {invalid argument caught
a
caught in_use_error
}

test implicit_tx {implicit transactions} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        implicit_tx := true;

        current_db := 'D';

        var r real relation {c string, n int, d float, s string}
            init relation { tuple { c 'xo', n 77, d 78.8, s 'Gr' } }
            key {c, n};

        insert r tuple { c 'Vanad', n 1234565, d 666.77, s 'Amethyst' };


        io.put((tuple from r where c = 'xo' and n = 77).s);
        io.put_line('');

        delete r where s = 'Gr';
        
        io.put((tuple from r).c); io.put_line('');
    }
} -result {Gr
Vanad
}

test rollback_r1 {rollback after real table creation} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;

        var r1 real rel{no int, s string} key{no};
        var r2 real rel{no1 int, no2 int};
        insert r2 tup{no1 1, no2 1};

        rollback;

        begin tx;

        try
            io.put_line(cast_as_string(count(r1)));
        catch err invalid_argument_error;
            io.put_line('invalid_argument_error caught (1)');
        end try;

        try
            io.put_line(cast_as_string(count(r2)));
        catch err invalid_argument_error;
           io.put_line('invalid_argument_error caught (2)');
        end try;

        try
            drop var r1;
        catch err invalid_argument_error;
            ;
        end try;
        try
            drop var r2;
        catch err invalid_argument_error;
            ;
        end try;
        commit;
    }
} -result {invalid_argument_error caught (1)
invalid_argument_error caught (2)
}

test rollback_r2 {rollback after real table creation followed by re-creating the tables} \
        -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;

        var r1 real rel{no int, s string} key{no};
        var r2 real rel{no1 int, no2 int};
        insert r2 tup{no1 1, no2 1};

        rollback;

        begin tx;

        -- Re-create tables w/ different heading
        var r1 real rel{no int} key{no};
        var r2 real rel{no int, s string};

        insert r1 tup{no 1};
        insert r2 tup{no 1, s 'truly relational'};

        io.put_line(cast_as_string((tuple from r1).no));
        io.put_line((tuple from r2).s);

        commit;
    }
} -result {1
truly relational
}

test rollback_v1 {rollback after virtual table creation} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r1 real rel{no int, s string} key{no};
        commit;
        
        begin tx;
        var v1 virtual r1 {no};
        var v2 virtual r1 where no<4;
        insert v2 tup{no 1, s 'Ey'};

        rollback;

        begin tx;

        try
            io.put_line(cast_as_string(count(v1)));
        catch err invalid_argument_error;
            io.put_line('invalid_argument_error caught (1)');
        end try;

        try
            io.put_line((tuple from v2).s);
        catch err invalid_argument_error;
           io.put_line('invalid_argument_error caught (2)');
        end try;

        try
            drop var v1;
        catch err invalid_argument_error;
            ;
        end try;
        try
            drop var v2;
        catch err invalid_argument_error;
            ;
        end try;

        commit;
    }
} -result {invalid_argument_error caught (1)
invalid_argument_error caught (2)
}

test rollback_v2 {rollback after real table creation followed by re-creating the tables} \
        -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r1 real rel {no int, s string} key {no, s} default { s '-' };
        commit;

        begin tx;

        var v1 virtual r1 rename { s as txt };
        var v2 virtual extend r1: { no_s := cast_as_string(no) };
        insert v1 tup {no 1, txt 'Franz jagt im komplett verwahlosten Taxi quer durch Bayern'};

        rollback;

        begin tx;

        -- Re-create tables w/ different heading
        var v1 real rel{no int} key{no};
        var v2 virtual r1 where no < 5;

        insert v1 tup{no 1};
        insert v2 tup{no 1, s 'truly relational'};

        io.put_line(cast_as_string((tuple from r1).no));
        io.put_line((tuple from v2).s);

        commit;
    }
} -result {1
truly relational
}

test rollback_p1 {rollback after virtual table creation} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r1 real rel{no int, s string} key{no};
        commit;
        
        begin tx;
        var p1 public rel{no int};
        map p1 r1 {no};
        var p2 public rel{no int, s string} key{no};
        map p2 r1 where no<4;
        insert p2 tup{no 1, s 'Ey'};

        rollback;

        begin tx;

        try
            io.put_line(cast_as_string(count(p1)));
        catch err invalid_argument_error;
            io.put_line('invalid argument or not found (1)');
        catch err name_error;
            io.put_line('invalid argument or not found (1)');
        end try;

        try
            io.put_line((tuple from p2).s);
        catch err invalid_argument_error;
            io.put_line('invalid argument or not found (2)');
        catch err name_error;
            io.put_line('invalid argument or not found (2)');
        end try;

        commit;
    }
} -result {invalid argument or not found (1)
invalid argument or not found (2)
}

test double_rtable {creating a table with the same name twice} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real relation { no int, name string } key {no};

        insert r rel { tup { no 2, name 'two' }, tup { no 3, name 'three' } };
        commit;

        begin tx;
        try
            var r real rel { n int, s string } key { n };
            commit;
        catch err element_exists_error;
            io.put_line('2nd creation caught');
            rollback;
        end try;

        begin tx;
        drop var r;
        var r real rel { id string, s string } key { id };
        commit;

        begin tx;
        insert r tup { id '01', s 'Test' };
        var tp init tuple from r;
        commit;
        io.put_line(tp.id || ' ' || tp.s);
    }
} -result {2nd creation caught
01 Test
}

test drop_nested_tx {dropping table in nested transaction} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real relation { no int, name string } key {no};

        insert r rel { tup { no 2, name 'two' }, tup { no 3, name 'three' } };
        commit;

        begin tx;
        begin tx;
        drop var r;
        commit;
        commit;
    }
}

test serial {system-generated attribute values} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real relation {no int, name string} key {no} default {no serial()};
        insert r tup{name 'Abc'};
        commit;

        begin tx;
        try ;
            insert r tup {no 2, name 'Tst'};
        catch err invalid_argument_error;
            io.put_line('insert caught');
        end try;
        insert r tup{name 'Def'};
        var tp tup same_heading_as(r);
        for tp in r order (no asc);
            io.put(tp.no);
            io.put(' ');
            io.put_line(tp.name);
        end for;
        drop var r;
        commit;

        begin tx;
        try
            var r2 real relation {no string, name string} key {no} default {no serial()};
            io.put_line('table creation with invalid default succeeded.');
        catch err invalid_argument_error;
            ;
        end try;
        rollback;
    }
} -result {insert caught
1 Abc
2 Def
}

test rename_real {rename table} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real relation {no int, name string}
                init rel { tup { no 1, name 'yo' },  tup { no 2, name 'yoyo' } }
                key {no};
        var v virtual r where no = 1;
        commit;
        
        begin tx;
        rename var v as v2;
        io.put((tuple from v2).no);
        io.put(' ');
        io.put_line((tuple from v2).name);

        drop var v2;
        rename var r as r2;
        var r real rel {i int};
        insert r tup{i 2};
        rename var r as r3;
        io.put((tuple from r3).i);
        io.put_line('');
        commit;
    }
} -result {1 yo
2
}

test rename_real_syskey {rename table with system key} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r1 real relation {no int, name string} key {no} default {no serial(), name 'John Doe'};
        insert r1 tup{};
        commit;
    }
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        rename var r1 as r2;
        commit;
    }
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        insert r2 tup{};
        var tp tup same_heading_as(r2);
        for tp in r2 order (no asc);
            io.put(tp.no);
            io.put(' ');
            io.put_line(tp.name);
        end for;
        drop var r2;
        commit;
    }
} -result {1 John Doe
2 John Doe
}

test array_attr {table with array-valued attribute} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real relation { no int, name string, names array string }
                init rel { tup { no 1, name "Z <= 1", names array('Hydrogen') },
                       tup { no 2, name "Z <= 2", names array('Hydrogen', 'Helium') } }
                key { no }; 
        insert r tup { no 3, name "Z <= 3",
                names array('Hydrogen', 'Helium', 'Lithium') };
        insert r rel { tup { no 4, name "Z <= 4",
                names array('Hydrogen', 'Helium', 'Lithium', 'Beryllium') } };
        commit;

        begin tx;
        var vr virtual r where if length(names) > 2 then names[2] = 'Lithium' else false; 
        commit;
    }
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;

        var tp tuple same_heading_as(r);

        for tp in r where index_of(names, 'Hydrogen') >= 0 order(no asc);
            io.put_line(tp.name);
            io.put_line(tp.names[length(tp.names) - 1]);
        end for;

        io.put_line('');

        for tp in vr order(no asc);
            io.put_line(tp.name);
            io.put_line(tp.names[length(tp.names) - 1]);
        end for;

        commit;
    }
} -result {Z <= 1
Hydrogen
Z <= 2
Helium
Z <= 3
Lithium
Z <= 4
Beryllium

Z <= 3
Lithium
Z <= 4
Beryllium
}

test same_op {operator definition with same_heading_as and same_type_as} \
             -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real init rel { tup { no 1, txt 'X' } };
        var t tup { s string };

        operator op(tr tup same_heading_as(r)) returns same_type_as(t);
            var rt same_type_as(t);
            update rt { s := tr.txt };
            return rt;
        end operator;

        io.put_line(op(tuple from r).s);
        commit;
    }
} -result {X
}

test 2dbs {2 databases} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        create_db('D2');
        current_db := 'D';
        begin tx;
        var r real init rel { tup { s 'y' } };
        commit;
        disconnect();
        
        case
        when os.getenv('DURO_STORAGE') = 'POSTGRESQL' then
            connect('postgresql:///testdb');
        when os.getenv('DURO_STORAGE') = 'FOUNDATIONDB' then
            connect('foundationdb://');
        else
            connect('dbenv');
        end case;
        current_db := 'D';
        begin tx;
        io.put_line((tuple from r).s);
        commit;
        current_db := 'D2';
        begin tx;
        try
            io.put_line((tuple from r).s);
            io.put_line('accessing r in db D2 succeeded');
        catch err name_error;
            ;
        end try;
        commit;
    }
} -result {y
}

test datetime_table {table with datetime attribute} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin tx;
        var dr real rel {n int, d datetime} key {n};
        insert dr rel { tup { n 1, d datetime(2015, 2, 1, 0, 0, 1) },
                        tup { n 2, d datetime(2014, 1, 1, 0, 0, 1) },
                        tup { n 3, d datetime(2015, 2, 1, 0, 0, 0) },
                        tup { n 4, d datetime(2015, 1, 15, 0, 0, 0) } };
        commit;
        
        begin tx;
        update dr where n = 2 { d := datetime(2015, 2, 2, 0, 0, 1) };
        var tp tup same_heading_as(dr);
        for tp in dr order (d asc);
            io.put(tp.n);
            io.put(' ');
            io.put(tp.d);
            io.put_line('');
        end for;
        commit;
    }
} -result {4 2015-01-15T00:00:00
3 2015-02-01T00:00:00
1 2015-02-01T00:00:01
2 2015-02-02T00:00:01
}

test nested_rollback {nested transactions rolled back} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin tx;
        var r real rel {n int, s string} key {n};
        commit;
        begin tx;
        begin tx;
        insert r tup {n 1, s '1'};
        rollback;
        rollback;
        begin tx;
        io.put_line(cast_as_string(count(r)));
        commit;
    }
} -result {0
}

test equality {table equality} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';
        begin tx;

        var r1 real rel {n int, s string}
            init rel { tup { n 1, s 'a' } } key {n};
        var r2 real init r1;
        io.put(r1 = r2);
        io.put_line('');

        insert r2 tup { n 2, s 'n' };

        io.put(r1 = r2);
        io.put_line('');

        var r3 real rel {n int, t string} key {n};
        try
            io.put(r1 = r3);
            io.put_line('');
            io.put_line('comparing tables of different types for equality succeeded');
        catch e type_mismatch_error;
            ;
        end try;
        commit;
    }
} -result {TRUE
FALSE
}

test nan {insert and read NaN into and from table} \
            -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e $dbenvname << {
        current_db := 'D';

        begin tx;
        var r real relation {k string, f float} key {k};
        insert r tup {k '1', f 1.0};
        insert r tup {k '2', f NaN};
        commit;
        
        begin tx;
        io.put((tuple from r where k = '2').f);
        io.put_line('');
        io.put_line((tuple from r where f = NaN).k);
        commit;
    }
} -result {NaN
2
}

cleanupTests
